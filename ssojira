#!/usr/bin/env ruby

require "optparse"
require "io/console"
require "json"

require "bundler/setup"
require "tty-prompt"
require "tty-cursor"
require "mechanize"
require "keyring"
require "paint"
require "vcr"

begin
  require "pry"
rescue LoadError
end

CACHE_TIME = 3600
CACHE_DIR = "request_cache"
CACHE_FILE = "jira_cache"

VCR.configure do |config|
  config.cassette_library_dir = CACHE_DIR
  config.hook_into :webmock
  config.allow_http_connections_when_no_cassette = true
  config.default_cassette_options = {
    record: :new_episodes,
    re_record_interval: CACHE_TIME,
    allow_unused_http_interactions: true,
    match_requests_on: [:uri, :method],
  }
end


def patch_mechanize
  Mechanize.class_eval do
    alias_method :original_get, :get

    define_method :get do |*args, **kwargs, &block|
      result = VCR.use_cassette(CACHE_FILE) do
        original_get(*args, **kwargs)
      end
      if block
        block.call(result)
      else
        result
      end
    end
  end
end


class JiraHandler
  PROJECT_KEYRING_SERVICE = "ssojira-project"
  COMPONENTS_KEYRING_SERVICE = "ssojira-components"
  USERNAME_KEYRING_SERVICE = "ssojira-user"
  APP_KEYRING_USER = "ssojira-cli"
  PASSWORD_KEYRING_SERVICE = "ssojira-password"
  URL_KEYRING_SERVICE = "ssojira-url"
  AUTH_DOMAIN_SERVICE = "ssojira-authdomain"
  DEFAULT_ACTION = :show
  DEFAULT_USERNAME = `git config user.email`.chomp
  ASSIGNED_TO_ME = "assignee=currentuser()"
  STATUS_OPEN = "%20status%20in%20(Open%2C%20%22In%20Progress%22%2C%20Reopened)%20"

  attr_accessor :issue, :action, :verbose, :pull_request_id
  attr_reader :prompt, :cursor

  def initialize
    @verbose = false
    @prompt = TTY::Prompt.new
    @cursor = TTY::Cursor
    @action = DEFAULT_ACTION
  end

  @@requires_issue = [:show, :pull_request, :comment]

  def action=(symbol)
    if action == DEFAULT_ACTION
      @action = symbol
    else
      error "Multiple actions given: #{action.to_s} and #{symbol.to_s}"
    end
  end

  def error(str)
    puts str
    exit -1
  end

  def get_secret(service, user, txt, force, secret: true, default: "")
    result = @keyring.get_password(service, user)
    if !result || force
      result = (secret ? prompt.mask(txt) : prompt.ask(txt, default: default))
      @keyring.set_password(service, user, result)
    end
    result
  end

  def login(force = false)
    @keyring ||= Keyring.new
    @url ||= get_secret(URL_KEYRING_SERVICE, APP_KEYRING_USER, "JIRA Url: ", force, secret: false)
    @authdomain ||= get_secret(AUTH_DOMAIN_SERVICE, @url, "Auth-Domain: ", force, secret: false)
    @username ||= get_secret(USERNAME_KEYRING_SERVICE, @url, "Username: ", force, secret: false, default: DEFAULT_USERNAME)
    @password ||= get_secret(PASSWORD_KEYRING_SERVICE, @username, "Password: ", force, secret: true)
    @project ||= get_secret(PROJECT_KEYRING_SERVICE, @url, "JIRA default project: ", force, secret: false)
    @components ||= get_secret(COMPONENTS_KEYRING_SERVICE, @username, "JIRA default components (comma-separated): ", force, secret: false)
  end

  def log(*args)
    puts args if verbose
  end

  def systemx(*args)
    exit -1 unless system(*args)
  end

  def list_issues(*jql)
    page = @agent.get("#{@url}/rest/api/latest/search?jql=#{jql.join('+AND+')}")
    results = JSON.parse(page.body)
    results["issues"].map do |issue|
      format_issue(issue)
    end
  end

  def list(jira_page)
    list_issues(ASSIGNED_TO_ME, STATUS_OPEN).each { |i| puts i }
  end

  def resolve(jira_page)
    issue_list = ["(cancel)"]
    issue_list += list_issues(ASSIGNED_TO_ME)
    selection = prompt.select("Resolve what?", issue_list, per_page: 15)
    exit if selection == issue_list[0]
    @issue = /([A-Z]+-\d+)/.match(selection)[1]

    # try to find transitions by common names
    page = @agent.get("#{@url}/rest/api/latest/issue/#{@issue}/transitions")
    transitions = JSON.parse(page.body)["transitions"]
    tid = transitions.find { |t| t["name"].downcase =~ "Resolve Issue" }
    tid ||= transitions.find { |t| t["name"].downcase =~ "resolve" }
    tid ||= transitions.find { |t| t["name"].downcase =~ "close issue" }
    tid ||= transitions.find { |t| t["name"].downcase =~ "close" }
    if tid.nil?
      error "Could not find a transition for resolving an issue"
    end

    data = {
      "fields" => {
        "resolution" => {
          "name" => "Fixed"
        }
      },
      "transition" => {
        "id" => tid["id"]
      }
    }

    page = @agent.post(
      "#{@url}/rest/api/latest/issue/#{@issue}/transitions",
      data.to_json,
      'Content-Type' => 'application/json'
    )

    results = JSON.parse(page.body)
    puts(results)
  end

  def pull_request(jira_page)
    origin_url = `git remote get-url origin`.chomp
    # switch to http(s)
    origin_url.sub!(/^ssh:\/\/([a-zA-Z0-9_]+@)?/, "https://")
    # remove ssh port
    origin_url.sub!(/:[0-9]+/, "")
    # transform repo path
    origin_url.sub!(/\/(?<project>\w+)\/(?<repo>[a-zA-Z0-9\-_]+)(\.git)?$/, '/projects/\k<project>/repos/\k<repo>')
    unless pull_request_id
      branches = `git branch --list`
      branches =~ /\s([^ ]+#{@issue}[^ ]+)/
      branch = $1
      if branch.nil?
        error "Could not find branch for issue #{@issue}"
      end
      prurl = "#{origin_url}/compare/commits?sourceBranch=refs/heads/#{branch}"
      command_success = false
      if RUBY_PLATFORM =~ /linux/
        command_success = system("xdg-open #{prurl}")
      elsif RUBY_PLATFORM =~ /windows/
        command_success = system("start #{prurl}")
      elsif RUBY_PLATFORM =~ /darwin/
        command_success = system("open #{prurl}")
      end
      puts "Open a PR at: #{prurl}" unless command_success
      id = prompt.ask "Enter pull-request ID (or nothing to cancel posting PR as a comment):"
      return unless id
    else
      id = pull_request_id
    end
    prviewurl = "#{origin_url}/pull-requests/#{id}/overview"
    if pull_request_id
      show(jira_page, detailed = false)
      return unless prompt.yes? "Post #{prviewurl} to #{@issue}?"
    end
    post_comment(jira_page, "Pull request: #{prviewurl}")
  end

  def comment(jira_page)
    comment = prompt.multiline("Enter comment (or nothing to cancel):").join
    return if comment.empty?
    post_comment(jira_page, comment)
  end

  def post_comment(jira_page, comment)
    comment_form = jira_page.form_with(action: /AddComment/)
    comment_text = comment_form.field_with(name: "comment")
    comment_text.value = comment
    comment_form.submit
  end

  def new_issue(jira_page)
    title = prompt.ask("Enter issue title (or nothing to cancel):")
    return unless title && !title.empty?
    body = prompt.multiline("Enter issue body").join
    project = prompt.ask("Enter project:", default: @project)
    components = prompt.ask("Enter components (comma-separated):", default: @components)
    type = prompt.ask("Enter issue type (Bug, Improvement, Task, ...)", default: "Task")

    data = {
      "fields" => {
        "project" => {"key" => project},
        "components" => components.split(",").map { |c| {"name" => c} },
        "summary" => title,
        "description" => body,
        "issuetype" => {
          "name" => type,
        },
      }
    }

    page = @agent.post(
      "#{@url}/rest/api/latest/issue",
      data.to_json,
      'Content-Type' => 'application/json'
    )

    results = JSON.parse(page.body)
    puts(results)
  end

  def print_issue(issue, detailed: false)
    puts format_issue(issue, detailed: detailed)
  end

  def format_issue(issue, detailed: false)
    out = []
    i = issue["fields"]
    key = issue["key"]
    begin
      key = Paint[key, i["status"]["statusCategory"]["colorName"].to_sym]
    rescue
      key = Paint[key, :white]
    end
    components = Paint["(#{i["components"].map { |c| c["name"] }.join(", ")})", "666"]
    url = Paint["#{@url}/browse/#{issue['key']}", "gray"]
    out << "#{key} '#{i['summary']}' -#{i['reporter']['displayName']} #{components} #{url}"

    if detailed
      if i['description']
        out << Paint["#{i['description']}\n", :white]
      end

      (i["comment"]&.[]("comments") || []).each do |comment|
        author = Paint["#{comment['author']['displayName']}", :white]
        body = Paint[comment['body']]
        out << "#{author}: #{body}\n\n"
      end
    end
    out.join("\n")
  end

  def require_issue(jira_page)
    error "No issue given" if @issue.nil?
    error "No such issue #{@issue}" unless jira_page.uri.to_s.end_with?(@issue)
  end

  def start(jira_page)
    unless @issue
      issue_list = ["(cancel)"]
      issue_list += list_issues(ASSIGNED_TO_ME, STATUS_OPEN)
      selection = prompt.select("Start working on what?", issue_list, per_page:  15)
      exit if selection == issue_list[0]
      @issue = /([A-Z]+-\d+)/.match(selection)[1]
      return go
    end
    require_issue(jira_page)
    systemx "git checkout master && git pull"
    systemx "git checkout -b topic/#{@issue}"
    log("Starting progress")
    jira_page.link_with(:text => "Start Progress")&.click
    log("Assigning to me")
    jira_page.link_with(:text => "Assign to me")&.click
  end

  def show(jira_page, detailed: true)
    page = @agent.get("#{@url}/rest/api/latest/search?jql=key=#{@issue}&fields=*all")
    results = JSON.parse(page.body)
    print_issue(results["issues"][0], detailed: detailed)
  end

  def open_branches(jira_page)
    branches = `git branch --list`.split("\n").map(&:chomp)
    worked_issues = {"(leave menu)" => nil}
    branch_prompt = "Switch to branch?"
    puts branch_prompt
    print "  ", worked_issues.keys.first, "\n"
    branches.each do |potential_issue_branch|
      if potential_issue_branch =~ /([a-zA-Z0-9]+\-[0-9]+)/
        potential_issue_name = $1
        begin
          page = @agent.get("#{@url}/rest/api/latest/search?jql=key=#{potential_issue_name}")
        rescue
          next
        end
        results = JSON.parse(page.body)
        issue_json = results["issues"][0]
        if issue_json
          issuestr = "#{potential_issue_branch} - #{format_issue(issue_json, detailed: false)}"
          worked_issues[issuestr] = potential_issue_branch.chomp.sub(/^\*\s+/, "")
          print "  ", issuestr, "\n"
        end
      end
    end
    print cursor.up(worked_issues.size + 2)
    print cursor.clear_screen_down
    selected_issue = prompt.select(branch_prompt, worked_issues, per_page: 15)
    if selected_issue
      systemx "git checkout #{selected_issue}"
    end
  end

  def do_action(jira_page)
    require_issue(jira_page) if @@requires_issue.include? action
    send action, jira_page
  end

  def go
    login

    @agent = Mechanize.new do |agent|
      agent.follow_meta_refresh = true
      agent.add_auth(@authdomain, @username, @password)
      agent.log = Logger.new(STDOUT) if verbose
    end

    @agent.get("#{@url}/browse/#{@issue}") do |page|
      log(page.uri)
      do_action(page)
    end
  end

  def self.handle_commandline
    jira = self.new
    should_patch = true
    OptionParser.new do |opts|
      opts.banner = "Usage: ssojira <issue_id> [options]"

      opts.on("-v", "--[no-]verbose", "Run verbosely") do |v|
        jira.verbose = v
      end

      opts.on("-s", "--start", "Create a branch and start working on an issue (interactive if no issue given).") do |v|
        jira.action = :start
      end

      opts.on("-l", "--list", "List issues assigned to me.") do |v|
        jira.action = :list
      end

      opts.on("-o", "--open-branches", "List branches that are open locally and their issues and optionally switch to one.") do |v|
        jira.action = :open_branches
      end

      opts.on("-a", "--authenticate", "Ask (again) for username and password.") do |v|
        jira.login(force = true)
      end

      opts.on("-r", "--resolve", "Resolve an open issue assigned to me") do |v|
        jira.action = :resolve
      end

      opts.on("-p", "--pull-request [ID]", "Open a PR for this issue, or post a PR url as comment on the issue") do |id, issue|
        jira.action = :pull_request
        jira.pull_request_id = id
      end

      opts.on("-c", "--comment", "Post a comment") do |v|
        jira.action = :comment
      end

      opts.on("-n", "--new", "Create a new issue") do |v|
        jira.action = :new_issue
      end

      opts.on("-f", "--refresh", "Don't use cache, force pulling fresh data.") do |v|
        self.clear_http_cache(Time.now)
        should_patch = false
      end

      opts.on_tail("-h", "--help", "Show this message") do
        puts opts
        exit
      end
    end.parse!

    patch_mechanize if should_patch
    clear_http_cache(Time.now - CACHE_TIME)

    jira.issue = ARGV.shift
    unless jira.action == :start
      # for start without an issue, we ask
      jira.issue ||= /([A-Z]+-\d+)/.match(`git rev-parse --abbrev-ref HEAD`)&.[](1)
    end
    jira
  end

  def self.clear_http_cache(offset)
    cachefile = "#{CACHE_DIR}/#{CACHE_FILE}.yml"
    File.unlink(cachefile) if File.exist?(cachefile) && File.ctime(cachefile) < offset
  end

  def self.go
    self.handle_commandline.go
  end
end


JiraHandler.go
