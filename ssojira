#!/usr/bin/env ruby

require "optparse"
require "io/console"
require "json"

require "bundler/setup"
require "mechanize"
require "keyring"
require "paint"

begin
  require "pry"
rescue LoadError
end


class JiraHandler
  USERNAME_KEYRING_SERVICE = "ssojira-user"
  APP_KEYRING_USER = "ssojira-cli"
  PASSWORD_KEYRING_SERVICE = "ssojira-password"
  URL_KEYRING_SERVICE = "ssojira-url"
  AUTH_DOMAIN_SERVICE = "ssojira-authdomain"
  DEFAULT_ACTION = :show

  attr_accessor :issue, :action, :verbose

  def initialize
    @verbose = false
    @action = DEFAULT_ACTION
  end

  @@requires_issue = [:start, :show, :pull_request, :comment]

  def action=(symbol)
    if action == DEFAULT_ACTION
      @action = symbol
    else
      error "Multiple actions given: #{action.to_s} and #{symbol.to_s}"
    end
  end

  def error(str)
    puts str
    exit -1
  end

  def get_secret(service, user, prompt, force, secret=true)
    result = @keyring.get_password(service, user)
    if !result || force
      print prompt
      result = (secret ? STDIN.noecho(&:gets) : STDIN.gets).chomp
      @keyring.set_password(service, user, result)
    end
    result
  end

  def login(force = false)
    @keyring ||= Keyring.new
    @url ||= get_secret(URL_KEYRING_SERVICE, APP_KEYRING_USER, "JIRA Url: ", force, secret=false)
    @authdomain ||= get_secret(AUTH_DOMAIN_SERVICE, @url, "Auth-Domain: ", force, secret=false)
    @username ||= get_secret(USERNAME_KEYRING_SERVICE, @url, "Username: ", force, secret=false)
    @password ||= get_secret(PASSWORD_KEYRING_SERVICE, @username, "Password: ", force, secret=true)
  end

  def log(*args)
    puts args if verbose
  end

  def list(jira_page)
    page = @agent.get("#{@url}/rest/api/latest/search?jql=assignee=currentuser()")
    results = JSON.parse(page.body)
    results["issues"].each do |issue|
      print_issue(issue)
    end
  end

  def pull_request(jira_page)
    origin_url = `git remote get-url origin`.chomp
    branches = `git branch --list`
    branches =~ /\s([^ ]+#{@issue}[^ ]+)/
    branch = $1
    if branch.nil?
      error "Could not find branch for issue #{@issue}"
    end
    # switch to http(s)
    origin_url.sub!(/^ssh:\/\/([a-zA-Z0-9_]+@)?/, "https://")
    # remove ssh port
    origin_url.sub!(/:[0-9]+/, "")
    # transform repo path
    origin_url.sub!(/\/(?<project>\w+)\/(?<repo>[a-zA-Z0-9\-_]+)(\.git)?$/, '/projects/\k<project>/repos/\k<repo>')
    prurl = "#{origin_url}/compare/commits?sourceBranch=refs/heads/#{branch}"
    command_success = false
    if RUBY_PLATFORM =~ /linux/
      command_success = system("xdg-open #{prurl}")
    elsif RUBY_PLATFORM =~ /windows/
      command_success = system("start #{prurl}")
    elsif RUBY_PLATFORM =~ /darwin/
      command_success = system("open #{prurl}")
    end
    puts "Open a PR at: #{prurl}" unless command_success
    print "Enter pull-request ID (or nothing to cancel posting PR as a comment): "
    id = STDIN.gets.chomp
    return if id.empty?
    post_comment(jira_page, "Pull request: #{origin_url}/pull-requests/#{id}/overview")
  end

  def comment(jira_page)
    print "Enter one-line comment (or nothing to cancel): "
    comment = STDIN.gets.chomp
    return if comment.empty?
    post_comment(jira_page, comment)
  end

  def post_comment(jira_page, comment)
    comment_form = jira_page.form_with(action: /AddComment/)
    comment_text = comment_form.field_with(name: "comment")
    comment_text.value = comment
    comment_form.submit
  end

  def print_issue(issue, detailed = false)
    i = issue["fields"]
    key = issue["key"]
    begin
      key = Paint[key, i["status"]["statusCategory"]["colorName"].to_sym]
    rescue
      key = Paint[key, :white]
    end
    components = Paint["(#{i["components"].map { |c| c["name"] }.join(", ")})", "666"]
    puts "#{key} '#{i['summary']}' -#{i['reporter']['displayName']} #{components}"

    if detailed
      puts "#{@url}/browse/#{@issue}"

      if i['description']
        puts Paint["#{i['description']}\n", :white]
      end

      (i["comment"]&.[]("comments") || []).each do |comment|
        author = Paint["#{comment['author']['displayName']}", :white]
        body = Paint[comment['body']]
        puts "#{author}: #{body}\n\n"
      end
    end
  end

  def require_issue(jira_page)
    error "No issue given" if @issue.nil?
    error "No such issue #{@issue}" unless jira_page.uri.to_s.end_with?(@issue)
  end

  def start(jira_page)
    system "git checkout -b topic/#{@issue}"
    log("Starting progress")
    jira_page.link_with(:text => "Start Progress")&.click
    log("Assigning to me")
    jira_page.link_with(:text => "Assign to me")&.click
  end

  def show(jira_page)
    page = @agent.get("#{@url}/rest/api/latest/search?jql=key=#{@issue}&fields=*all")
    results = JSON.parse(page.body)
    print_issue(results["issues"][0], detailed = true)
  end

  def open_branches(jira_page)
    branches = `git branch --list`.split("\n").map(&:chomp)
    branches.each do |potential_issue_branch|
      if potential_issue_branch =~ /([a-zA-Z0-9]+\-[0-9]+)/
        potential_issue_name = $1
        begin
          page = @agent.get("#{@url}/rest/api/latest/search?jql=key=#{potential_issue_name}")
        rescue
          next
        end
        results = JSON.parse(page.body)
        issue_json = results["issues"][0]
        print_issue(issue_json, detailed = false) if issue_json
      end
    end
  end

  def do_action(jira_page)
    require_issue(jira_page) if @@requires_issue.include? action
    send action, jira_page
  end

  def go
    login

    @agent = Mechanize.new do |agent|
      agent.follow_meta_refresh = true
      agent.add_auth(@authdomain, @username, @password)
    end

    @agent.get("#{@url}/browse/#{@issue}") do |page|
      log(page.uri)
      do_action(page)
    end
  end

  def self.handle_commandline
    jira = self.new
    OptionParser.new do |opts|
      opts.banner = "Usage: ssojira <issue_id> [options]"

      opts.on("-v", "--[no-]verbose", "Run verbosely") do |v|
        jira.verbose = v
      end

      opts.on("-s", "--start", "Create a branch and start working on this issue.") do |v|
        jira.action = :start
      end

      opts.on("-l", "--list", "List issues assigned to me.") do |v|
        jira.action = :list
      end

      opts.on("-o", "--open-branches", "List branches that are open locally and their issues.") do |v|
        jira.action = :open_branches
      end

      opts.on("-a", "--authenticate", "Ask (again) for username and password.") do |v|
        jira.login(force = true)
      end

      opts.on("-p", "--pull-request", "Open a PR for this issue") do |v|
        jira.action = :pull_request
      end

      opts.on("-c", "--comment", "Post a comment") do |v|
        jira.action = :comment
      end

      opts.on_tail("-h", "--help", "Show this message") do
        puts opts
        exit
      end
    end.parse!

    jira.issue = ARGV.shift || /(GR-\d+)/.match(`git rev-parse --abbrev-ref HEAD`)&.[](1)
    jira
  end

  def self.go
    self.handle_commandline.go
  end
end


JiraHandler.go
